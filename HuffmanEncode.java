import java.io.*;
import java.nio.ByteBuffer;
import java.util.*;

public class HuffmanEncode {

	CharNode overallRoot;
	String  fileInput;
	FileReader output;
	FileInputStream byteOutput;
	private int leafCount;

	/**
	 * @param object
	 *            The text file to read
	 * @throws IOException
	 *             Throws exception if it's not readable
	 */
	public HuffmanEncode(File object) throws IOException {
		output = new FileReader(object);
	}

	/**
	 * Reads the filename and creates a File Object which will be used in a
	 * FileInputStream. This changes the program to encode in bytes rather than
	 * characters.
	 *
	 * @param fileName name of the text file to open
	 * @throws FileNotFoundException throw exception if the file does not exist
	 */
	public HuffmanEncode(String fileName) throws FileNotFoundException {
		byteOutput = new FileInputStream(fileName);
        fileInput = fileName;
	}

	/**
	 * Reads the FileInputStream and counts the occurrence of every byte. Fills
	 * the PriorityQueue with the nodes that you create out of bytes and
	 * occurrences. Builds the Huffman Tree and Traverses the tree.
	 *
	 * @throws IOException
	 */
	public void encodeByteStream() throws IOException {
		// The traversal method should store the following info into a
		// HashMap<K, V> for every leaf node
		// Bytes as K (key) of type Integer (don't use Byte because of a signed
		// problem)
		// Huffman code as V (value) of type String

		// Generate the initial HashMap of integer bytes and integer occurrences
		HashMap<Integer, Integer> byteMap = new HashMap<Integer, Integer>();
		int c;
		while ((c = byteOutput.read()) != -1) {
            //numberOfBytes++;
			byteMap.putIfAbsent(c, 0);
			byteMap.replace(c, (c) + 1);
			System.out.println("(" + c + ", " + c + ")");
		}
		byteOutput.close();

		// Push the HashMap values into a PriorityQueue as new character Nodes
		// (CharNode)
		PriorityQueue<CharNode> byteQueue = new PriorityQueue<CharNode>();
		for (Map.Entry<Integer, Integer> item : byteMap.entrySet()) {
			byteQueue.add(new CharNode(item.getKey(), null, null, item.getValue()));
		}

		// Combine the Nodes in the queue until only 1 remains. That is the
		// Huffman Tree
		while (byteQueue.size() > 1) {
			CharNode temp1 = byteQueue.remove(); // pop out the two smallest value
			// nodes
			CharNode temp2 = byteQueue.remove(); // and create a new node from the
			// two
			CharNode newNode = new CharNode(null, temp1, temp2, temp1.weight + temp2.weight);
			temp1.parent = temp2.parent = newNode;
			byteQueue.add(newNode); // add it back into the pile
		}

		// Remove the last remaining Node from the PriorityQueue and save it as overallRoot
		overallRoot = byteQueue.remove();

		// Create a byte map and generate it's binary values from the HuffmanTree
		Map<Integer, String> encodeMap = genMap(overallRoot);

		// Output the generated values from the generated byte map
		System.out.println(encodeMap.toString());

        writeToFile("output.txt");
	}

	/**
	 * Create the compressed file by writing the compressed values to a file
	 * @param fileName the name of the original file
     */
	public void writeToFile(String fileName) throws IOException {

			// ------------------- START HEADER -------------------
		// Write the file header info (FHI). The FHI will be written byte by byte during creation to file.
		long numberOfBytes = 0; // Number of bytes in the original file
							// The long cannot be written directly. Split that number into bytes.
							// REQUIREMENT: The highest significant byte first, continue with less
							// significant bytes, least significant, etc.
		int numberOfSymbols; // # of different Bytes(Symbols) found in the original file that got encoded.
							// You cannot write to int directly. Split that number into bytes.
							// REQUIREMENT: The highest significant byte first, continue with less
							// significant bytes, least significant, for each symbol you write.
		numberOfSymbols = leafCount;
		System.out.println("\nNumber of Symbols: " + numberOfSymbols + "\n");
		byte symbolValue;
		byte coldLength; // the length of the "01010111" codeString for this symbol
		//byte(s) codebits; // for each '0', a bit 0 and for each '1', a bit 1 set. The # of codebits determines
						// the codeLength (<= one byte, >8 <= 16 two bytes, etc

        // ----------- START CALCULATING # OF BYTES IN ORIGINAL FILE --------------
        byte[] chunks = null;
        BufferedReader  in = new BufferedReader (new FileReader(fileInput));
        String eachLine;
        while( (eachLine = in.readLine()) != null)
        {
            chunks = eachLine.getBytes("UTF-8");
            System.out.println("The byte array \"chunks\" length: " + chunks.length);
            if (chunks != null) {
                numberOfBytes += chunks.length;
            }
        }
        System.out.println("The number of bytes in the original file: " + numberOfBytes + "\n");


        // ------------ END CALCULATE NUMBER OF BYTES IN ORIGINAL FILE -----------

        // Create bytes file from compressed file
        ByteBuffer bz = ByteBuffer.allocate(8);
		bz.putLong(numberOfBytes);

		byte[] result = bz.array();

		for (byte b : result) {
			System.out.println(b);
		}
		// ----------------------- END HEADER ----------------------

		// After the header, the bit stream of the encoded bytes follow. Here is an example:
		// Assuming you have the following mapping (I use chars as symbols for simplicity)
		// 'T' '110100', 'h' '10111', 'e' '1001', ' ' '111', 'b' '011100' the foxtext.hzip file would start
		// right after the above described File Header Info with the following 3 bytes (Each block represents
		// a byte in the file):
		// 11010010   11110011   11011100

		/*
		Possible code

		 */

	}

	/**
	 * @param root
	 *            The current node the method is generating from
	 * @return The updated map with added character and binary path
	 */
	private Map<Integer, String> genMap(CharNode root) {
		Map<Integer, String> map = new HashMap<>();
		traversal(map, root, "");
		return map;
	}

	/**
	 * @param map
	 *            The map of characters and it's binary path in a String
	 * @param root
	 *            The current node this method is traversing
	 * @param path
	 *            The String for storing the binary path
	 */
	private void traversal(Map<Integer, String> map, CharNode root, String path) {
		if (root.isLeaf()) {
			leafCount++;
			map.put(root.symbolValue, path);
		} else {
			traversal(map, root.leftChild, path + '0');
			traversal(map, root.rightChild, path + '1');
		}
	}

	/**
	 * @author Chris Mendoza
	 *
	 *         Custom Character Node class for building the Huffman Tree.
	 *         Implements Comparable for the priorityQueue to use in
	 *         HuffmanEncode
	 *
	 */
	private class CharNode implements Comparable<CharNode> {

		// private Character symbol; // char to be encoded, empty if combined node
		private Integer symbolValue;
		CharNode leftChild;
		CharNode rightChild;
		CharNode parent;
		Integer weight; // occurrence # of this char in the text


//		public CharNode(Character symbol, CharNode leftChild, CharNode rightChild, Integer weight) {
//			this.symbol = symbol;
//			this.leftChild = leftChild;
//			this.rightChild = rightChild;
//			this.weight = weight;
//		}

		/**
		 * Constructor
		 *
		 * @param byteValue
		 *            The character (a, b, c, etc)
		 * @param leftChild
		 *            The pointer to the left branch - NULL by default
		 * @param rightChild
		 *            The pointer to the right branch - NULL by default
		 * @param weight
		 *            The number of occurrences of this character
		 */
		public CharNode(Integer byteValue, CharNode leftChild, CharNode rightChild, Integer weight) {
			this.symbolValue = byteValue;
			this.leftChild = leftChild;
			this.rightChild = rightChild;
			this.weight = weight;
		}

		/**
		 * @return Whether this node is a leaf by checking the left and right
		 *         nodes
		 */
		public boolean isLeaf() {
			return leftChild == null && rightChild == null;
		}

		public int getWeight() {
			return weight;
		}

		/*
		 * Checks the occurrences of this node against the passed node
		 */
		public int compareTo(CharNode o) {
			return this.weight - o.weight;
		}

	}
}
